/*
  В этом примере показано, как работать с настройками модуля от EBYTE.
*/

#include <SoftwareSerial.h>
#include "EBYTE22.h"

// Константы для Arduino

#define PIN_TX 2
#define PIN_RX 3
#define PIN_M0 4
#define PIN_M1 5
#define PIN_AX 6

// Константы для плат на ESP8266
/*
#define PIN_RX 14
#define PIN_TX 12
#define PIN_M0 5
#define PIN_M1 4
#define PIN_AX 13
*/



SoftwareSerial E22Serial(PIN_TX, PIN_RX, false);  // Создаем объект SoftwareSerial для соединения с модулем через программный UART

EBYTE22 E22(&E22Serial, PIN_M0, PIN_M1, PIN_AX);  // Создаем экземпляр класса EBYTE22

void setup() {
 Serial.begin(9600);                              // Устанавливаем соединение с компьютером (телефоном) для отладки.
 E22Serial.begin(9600);                           // Устанавливаем соединение с модулем (скорость 9600).
 Serial.println("Starting Sender");
delay(200);
 
 // При инициализации и некоторых других операциях (применение настроек, установка ключа), модуль переходит в режим конфигурации, в этом режиме UART модуля работает только на скорости 9600!!!
 // Метод возвращает значение типа bool (true - успех, false - ошибка).
  if(E22.init())                                  // Инициализируем модуль(конфигурируются выводы контроллера, считываются настройки модуля).
 {Serial.println("init OK");} else{
  Serial.println("init Error");}                  // Если что-то пошло не так, выводим сообщение об ошибке.
 
// В случае ошибки, проверьте правильность подключения и перезапустите модуль с контроллером сбросом питания (кнопка сброса контроллера НЕ ПОМОГАЕТ).

/* Выбор режима работы модуля. Возможные аргументы: 
 * MODE_NORMAL - Нормальный режим. Модуль может передавать и принимать данные.
 * MODE_WOR -    Перед передачей отправляется преамбула для пробуждения приемника( если настроен как передатчик WOR)
 * MODE_CONFIG - Режим конфигурации (для чтения и записи настроек). Скорость UART только 9600.
 * MODE_SLEEP -  Режим сна, потребление энергии минимальное, прием, передача и конфигурация не выполняются.
 */
 E22.setMode(MODE_NORMAL);
   
/*
  Дальше идут методы для установки настроек. 
  ВНИМАНИЕ. Эти методы всего лишь меняют значения настроек в библиотеке,
  чтобы их применить, нужно отправить их в модуль.
*/

/*
  Установка адреса модуля. Адрес 0xFFFF - отключает функцию адресации.
  В таком случае модуль будет получать данные, даже если они адресованы не ему.
*/
 E22.setAddressH(0x00);   // Верхний байт Возможные значения: 0x00-0xFF (0-255)
 E22.setAddressL(0x00);   // Нижний байт  Возможные значения: 0x00-0xFF (0-255)
 E22.setAddress(0x0000);  // 2 байта адреса целиком (так удобнее) Возможные значения: 0x0000-0xFFFF (0-65535)


// Установка идентификатора сети. Он должен быть одинаковым для модулей, "общающихся" между собой.
 E22.setNetID(0x00); // Возможные значения: 0x00-0xFF (0-255)

/*
 Скорость передачи данных по UART (бод/сек), в режиме конфигурации всегда используется 9600.
 Возможные аргументы:
 UBR_1200    -  1200 
 UBR_2400    -  2400 
 UBR_4800    -  4800 
 UBR_9600    -  9600  по умолчанию
 UBR_19200   -  19200 
 UBR_38400   -  34800 
 UBR_57600   -  57600 
 UBR_115200  -  115200 
 */
 E22.setUARTBaudRate(UBR_9600);

/*
 Параметры бита четности для UART, в режиме конфигурации всегда используется 8N1.
 Возможные аргументы:
 PB_8N1     по умолчанию
 PB_8O1
 PB_8E1
*/
 E22.setParityBit(PB_8N1);

 /*
 Скорость передачи данных по радиоканалу, два модуля должны иметь одинаковую скорость, иначе они не "поймут" друг друга.
 Возможные аргументы:
 ADR_300     - 300 
 ADR_1200    - 1200 
 ADR_2400    - 2400  по умолчанию
 ADR_4800    - 4800 
 ADR_9600    - 9600 
 ADR_19200   - 19200 
 ADR_38400   - 38400 
 ADR_62500   - 62500 
 */
 E22.setAirDataRate(ADR_2400);

 /*
 Длина субпакета (байт). Данные передаются частями, если превышают длину одного пакета.
 Возможные аргументы:
 PACKET240 - 240   по умолчанию
 PACKET128 - 128
 PACKET64  - 64
 PACKET32  - 32
 */
 E22.setPacketLength(PACKET240);

/*
 Определяет возможность запросить RSSI в нормальном режиме или в режиме WOR.
 Возможные аргументы:
 RSSI_ENABLE  - Запрос RSSI разрешен.
 RSSI_DISABLE - Запрос RSSI запрещен.
 */

 E22.setRSSIAmbient(RSSI_ENABLE);

 /*
 Мощность передатчика.
 Возможные аргументы:
 // Для модулей мощностью   30dbm:    22dbm:
 TP_MAX   - 30dbm   22dbm
 TP_HIGH  - 27dbm   17dbm
 TP_MID   - 24dbm   13dbm
 TP_LOW   - 21dbm   10dbm
 */
 E22.setTransmitPower(TP_LOW);

 // Канал радиосвязи 0-83. Частота рассчитывается как 410.125 + канал (для модулей на 433МГц)
 // У модулей на другой частотный диапазон, количество каналов и формула для расчета частоты будут отличаться.
 E22.setChannel(23);

 /*
 Добавление значения RSSI (1 байт) в конец принятых данных.
 Возможные аргументы:
 RSSI_ENABLE  - Добавлять значение RSSI.
 RSSI_DISABLE - Не добавлять.
 */
 E22.setRSSIInPacket(RSSI_DISABLE);

 /*
 Режим передачи данных. ВНИМАНИЕ!! При адресной передаче, первые 2 байта расцениваются как целевой адрес и еще 1 байт как канал передачи.
 В библиотеке, для этого случая, предусмотрен метод "sendTarget", который нужно вызывать перед отправкой данных, иначе модуль определит первые 3 байта ваших данных
 как цель, и осуществит передачу неизвестно куда.
 Возможные аргументы:
 TXM_FIXED        - Передача на определенный адрес
 TXM_NORMAL       - Передача на тот же адрес, на который настроен сам модуль
 */
 E22.setTransmissionMode(TXM_NORMAL);

 /*
 Функция репитера.
 Возможные аргументы:
 REPEATER_ENABLE  - Включить
 REPEATER_DISABLE - Выключить
 */
 E22.setRepeater(REPEATER_DISABLE);

 /*
 Мониторинг канала перед передачей, как я понял, позволяет в некоторой степени предотвратить передачу данных в то время, когда передачу производит другой модуль.
 Возможные аргументы:
 LBT_ENABLE  - Включить
 LBT_DISABLE - Выключить
 */
 E22.setLBT(LBT_DISABLE);

 /*
 Влияет на работу только в режиме WOR! Если установлен как передатчик, то перед передачей данных, модуль будет транслировать маркер, чтобы приемник "не проспал" сам пакет.
 Если установлен как приемник, модуль будет "спать" и "просыпаться" через определенные периоды времени, "услышав" маркер, будет готов к приему. Такая схема работы позволяет экономить энергию.
 Помните, что в режиме WOR возможна только односторонняя связь.
 Возможные аргументы:
 WOR_TRANSMITTER   - Передатчик WOR
 WOR_RECEIVER      - Приемник WOR
 */
 E22.setWOR(WOR_TRANSMITTER);

 /*
 Влияет на работу только в режиме WOR! Время трансляции маркера передатчика, а также цикл пробуждения приемника.
 Передатчик и приемник должны иметь одинаковое значение.
 Возможные аргументы:
 WOR500   -  500мс (0.5сек.)
 WOR1000  -  1000мс
 WOR1500  -  2500мс
 WOR2000  -  2000мс
 WOR2500  -  2500мс
 WOR3000  -  3000мс
 WOR3500  -  3500мс
 WOR4000  -  4000мс
 */
 E22.setWORCycle(WOR2000);

 // --------- КОНЕЦ НАСТРОЕК ----------

 // Что делать с настройками, которые мы изменили?
 // Внимание, следующие методы (до конца метода setup) временно переводят модуль в режим конфигурации, в этом режиме UART модуля работает только на скорости 9600 (даже если в настройках скорость другая).

    E22.writeSettings(TEMPORARY);          // Отправить в модуль (PERMANENT - применить и сохранить в ПЗУ, TEMPORARY - применить до потери питания)
 // E22.writeSettingsWireless(TEMPORARY);  // Отправить настройки на удаленный модуль (PERMANENT - применить и сохранить в ПЗУ удаленного модуля, TEMPORARY - применить до потери питания)
 // E22.readSettings();                  // Считать настройки из модуля в библиотеку (несохраненные изменения удаляются).
 // E22.readSettingsWireless();            // Загрузить в библиотеку настройки с удаленного модуля (несохраненные изменения удаляются).
 //Эти методы возвращают переменную типа "bool", можно проверить успешность применения настроек:
/* 
 if(E22.writeSettings(TEMPORARY))
 {Serial.println("SET OK");} else{
  Serial.println("SET Error");}
*/

/*
 Установка криптографического ключа. Применяется сразу. Если у модулей установлены разные ключи, при приеме будут приходить искаженные данные.
 Метод возвращает значение типа bool (true - успех, false - ошибка).
 1й аргумент: 0x0000-0xFFFF (0-65535)
 2й аргумент:
 PERMANENT - Применить и сохранить в ПЗУ. 
 TEMPORARY - Применить до потери питания.
 */
 E22.writeCryptKey(0x0000, TEMPORARY);

  // Установка криптографического ключа на удаленный модуль. Аргументы те же. Метод возвращает значение типа bool (true - успех, false - ошибка).
  
  // E22.writeCryptKeyWireless(0x0000, TEMPORARY);
/*
 Следующий метод актуален только для приемника, работающего в режиме "WOR".
 После приема данных, приемник WOR, в течении некоторого времени имеет возможность отправить ответ, после чего вернется в цикл ожидания маркера.
 С помощью следующего метода можно установить это время в мс (0 - 65535). По умолчанию - 0.
 Настройка применится сразу же, временно или с сохранением в ПЗУ. Метод возвращает значение типа bool (true - успех, false - ошибка).
 Первый аргумент - время в мс: 0 - 65535
 Второй аргумент - способ применения: PERMANENT - применить и сохранить в ПЗУ, TEMPORARY - применить до потери питания.
*/
 // E22.writeWORReceiverDelay(2000, TEMPORARY);

}


void loop() {
/*
 Методы для установки режима работы и настроек, имеют одноименные методы с приставкой get (вместо set).
 Они позволяют получить текущие значения настроек из библиотеки (но не из модуля, если вы их меняли и не применили, исключение - метод "getMode", так как установленный режим применяется сразу).
 Эти методы возвращают 8-ми битное число (кроме метода getAddress, который возвращает 16 бит).
 Чтобы не разбираться с непонятными числами, сравнивайте полученное значение с соответствующими константами (где они есть).
 В следующем примере мы создадим переменную типа bool, которая изменит свое значение, если хоть одно значение настроек не будет соответствовать тому, что мы установили ранее.
*/

bool settingsOK = true; // Создаем переменную settingsOK, и присваиваем ей значение "true".

  // Если кто забыл "!=" - это оператор сравнения "не равно", то есть 2!=3 вернет "true"
if(E22.getMode()!=MODE_NORMAL) {settingsOK = false;}       // Если текущий режим работы не "Нормальный" (а какой-то другой), изменим значение логической переменной "settingsOK" на "false".
if(E22.getAddressH()!=0x00) {settingsOK = false;}          // Если верхний байт адреса не 0x00, изменим значение логической переменной "settingsOK" на "false".
if(E22.getAddressL()!=0x00) {settingsOK = false;}          // И так далее..... В итоге, если хоть одна настройка не совпадает с той, что мы ранее установили, переменная
if(E22.getAddress()!=0x00) {settingsOK = false;}           // "settingsOK" изменит свое значение на "false".
if(E22.getNetID()!=0x00) {settingsOK = false;}
if(E22.getUARTBaudRate()!=UBR_9600) {settingsOK = false;}
if(E22.getParityBit()!=PB_8N1) {settingsOK = false;}
if(E22.getAirDataRate()!=ADR_2400) {settingsOK = false;}
if(E22.getPacketLength()!=PACKET240) {settingsOK = false;}
if(E22.getRSSIAmbient()!=RSSI_ENABLE) {settingsOK = false;}
if(E22.getTransmitPower()!=TP_LOW) {settingsOK = false;}
if(E22.getChannel()!=23) {settingsOK = false;}
if(E22.getRSSIInPacket()!=RSSI_DISABLE) {settingsOK = false;}
if(E22.getTransmissionMode()!=TXM_NORMAL) {settingsOK = false;}
if(E22.getRepeater()!=REPEATER_DISABLE) {settingsOK = false;}
if(E22.getLBT()!=LBT_DISABLE) {settingsOK = false;}
if(E22.getWOR()!=WOR_TRANSMITTER) {settingsOK = false;}
if(E22.getWORCycle()!=WOR2000) {settingsOK = false;}

  // Выведем результат в монитор порта
if (settingsOK == true) { Serial.println("Настройки не изменились"); }            
if (settingsOK == false) { Serial.println("Одна или несколько настроек были изменены"); } 

  // У модуля есть возможность получить некую информацию о продукте. Что эта информация означает - неизвестно.
byte info[7];                       // Создаем массив типа "byte", длиной 7.
E22.readProductInfo(info);  // Записываем информацию о продукте в этот массив. Что делать дальше с этими данными, решать вам.
  // Внимание, метод "readProductInfo" временно переводит модуль в режим конфигурации, в этом режиме UART модуля работает только на скорости 9600 (даже если в настройках скорость другая).
  // Метод readProductInfo возвращает значение типа bool (true - успех, false - ошибка).

delay(5000);

}
