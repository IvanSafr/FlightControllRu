/*
  В этом примере показано, как отправлять данные различных типов.
  При использовании разнотипных контроллеров, пример может не работать (из-за различного представления структур).
*/

#include <SoftwareSerial.h>
#include "EBYTE22.h"

// Константы для Arduino

#define PIN_TX 2
#define PIN_RX 3
#define PIN_M0 4
#define PIN_M1 5
#define PIN_AX 6

// Константы для плат на ESP8266
/*
#define PIN_RX 14
#define PIN_TX 12
#define PIN_M0 5
#define PIN_M1 4
#define PIN_AX 13
*/



SoftwareSerial E22Serial(PIN_TX, PIN_RX, false);    // Создаем объект SoftwareSerial для соединения с модулем через программный UART

EBYTE22 E22(&E22Serial, PIN_M0, PIN_M1, PIN_AX);   // Создаем экземпляр класса EBYTE22

  // Переменные с данными, которые будем отправлять на другой модуль (байт, строка и структура, которая содержит несколько объектов разного типа).
byte testByte = 123;
String testString = "TEST";

struct myStruct                            // Не используйте строки в структурах, потому что из-за них невозможно узнать реальный размер структуры в байтах.
{                                          // На различных контроллерах, некоторые типы данных могут отличаться разрядностью.
  int days = 365;                          // В таком случае, передавать их с помощью структур нельзя.
  float pi = 3.14;                         // Ардуино и платы на ESP8266 как раз такой случай, даже при использовании типов с одинаковой разнядностью,
  long lightSpeed = 299792458;             // общий размер структуры отличается.
  char ch = 'X';
} testStruct;

void setup() {
 Serial.begin(9600);                       // Устанавливаем соединение с компьютером (телефоном) для отладки.
 E22Serial.begin(9600);                    // Устанавливаем соединение с модулем (скорость 9600).
 Serial.println("Starting Sender");
delay(200);
 
  // При инициализации и некоторых других операциях (применение настроек, установка ключа), модуль переходит в режим конфигурации, в этом режиме UART модуля работает только на скорости 9600!!!
  if(E22.init())                           // Инициализируем модуль(конфигурируются выводы контроллера, считываются настройки модуля).
 {Serial.println("init OK");} else{
  Serial.println("init Error");}           // Если что-то пошло не так, выводим сообщение об ошибке.
 
// В случае ошибки, проверьте правильность подключения и перезапустите модуль с контроллером сбросом питания (кнопка сброса контроллера НЕ ПОМОГАЕТ).

}

void loop() {

if (E22.getBusy()){                        // Если модуль чем-то занят (на выводе AUX логический 0), 
  E22.completeTask(5000);                  // подождем, пока освободится с таймаутом в 5 секунд.
}
  
/*
  Отправляем структуру. В качестве первого аргумента должен быть адрес на структуру.
  Для этого перед именем переменной пишется символ "&", подробнее см. "C++ работа с указателями".
  В качестве второго аргумента - размер структуры в байтах. Используйте функцию sizeof, как это показано ниже.
  Если ваша структура содержит строки (String), метод sizeof не сможет правильно определить размер структуры,
  что приведет к ошибкам. Поэтому передавайте строки отдельно.
  Метод "sendStruct" возвращает значение типа bool (true - успех, false - ошибка).
*/
E22.sendStruct(&testStruct, sizeof(testStruct));

  // Отправляем один байт
E22.sendByte(testByte);

  // Отправляем строку. В библиотеке EBYTE22 нет методов для этого, но можно взаимодействовать с объектом SoftwareSerial напрямую,
  // а уже у него есть метод print(String) (унаследованный от класса Stream, но это неважно), с помощью которого можно отправить строку в последовательный порт,
  // к которому подключен модуль.
E22Serial.print(testString);

  // Ожидаем окончание передачи данных по UART от микроконтроллера к модулю.
  // На данный момент в этом нет необходимости, просто знайте, что такая возможность есть.
E22.flush();

delay(5000); // Подождем немного

}
